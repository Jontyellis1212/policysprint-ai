// lib/pdf/renderPolicyPdf.ts
import PDFDocument from "pdfkit";

type RenderArgs = {
  businessName?: string;
  country?: string;
  industry?: string;
  policyText: string;
  preview?: boolean; // watermark if true
};

export function renderPolicyPdfToBuffer(args: RenderArgs): Promise<Buffer> {
  const { businessName = "", country = "", industry = "", policyText, preview = false } = args;

  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: "A4",
        margin: 54,
        bufferPages: true,
        compress: true,
      });

      const chunks: Buffer[] = [];
      doc.on("data", (c) => chunks.push(c));
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      doc.on("error", reject);

      const pageW = doc.page.width;
      const pageH = doc.page.height;

      const M = doc.page.margins.left; // 54
      const headerH = 64;
      const footerH = 44;

      const cardX = M;
      const cardW = pageW - M * 2;

      const cardTop = M + headerH - 18;
      const cardBottom = pageH - M - footerH + 18;
      const cardH = cardBottom - cardTop;

      const pad = 22;
      const contentX = cardX + pad;
      const contentW = cardW - pad * 2;
      const contentTop = cardTop + pad;
      const contentBottom = cardTop + cardH - pad;

      const metaLeft = businessName?.trim() || "AI Use Policy";
      const metaRightParts = [industry?.trim(), country?.trim()].filter(Boolean);
      const metaRight = metaRightParts.join(" · ");

      const normalFont = "Helvetica";
      const boldFont = "Helvetica-Bold";

      function drawPageChrome() {
        // background
        doc.save();
        doc.rect(0, 0, pageW, pageH).fill("#ffffff");
        doc.restore();

        // header (subtle brand)
        doc.save();
        doc.fillColor("#0f172a");
        doc.font(boldFont).fontSize(10);
        doc.text(metaLeft, M, M, { width: pageW - M * 2, align: "left" });

        doc.font(normalFont).fontSize(9).fillColor("#64748b");
        doc.text(metaRight, M, M, { width: pageW - M * 2, align: "right" });
        doc.restore();

        // card background (EVERY PAGE)
        doc.save();
        doc.fillColor("#f1f5f9"); // slate-100-ish
        doc.roundedRect(cardX, cardTop, cardW, cardH, 18).fill();
        doc.restore();

        // watermark for preview
        if (preview) {
          doc.save();
          doc.rotate(-18, { origin: [pageW / 2, pageH / 2] });
          doc.fillColor("#0f172a").opacity(0.08);
          doc.font(boldFont).fontSize(56);
          doc.text("PREVIEW — Upgrade to download", 0, pageH / 2 - 40, {
            width: pageW,
            align: "center",
          });
          doc.opacity(1);
          doc.restore();
        }

        // footer
        doc.save();
        doc.fillColor("#94a3b8");
        doc.font(normalFont).fontSize(9);
        doc.text("Generated by PolicySprint AI", M, pageH - M - 18, {
          width: pageW - M * 2,
          align: "left",
        });
        doc.text(new Date().toLocaleDateString(), M, pageH - M - 18, {
          width: pageW - M * 2,
          align: "right",
        });
        doc.restore();
      }

      function isHeading(line: string) {
        const t = line.trim();
        if (!t) return false;
        // e.g. "1. Purpose" or "10. Training"
        if (/^\d{1,2}\.\s+\S+/.test(t)) return true;
        // fallback: short ALL CAPS headings
        if (t.length <= 48 && t === t.toUpperCase() && /[A-Z]/.test(t)) return true;
        return false;
      }

      function normLines(text: string) {
        return (text || "")
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n")
          .split("\n")
          .map((l) => l.trimEnd());
      }

      // Start
      drawPageChrome();

      let y = contentTop;

      const writeBlock = (text: string, opts: { heading?: boolean } = {}) => {
        const heading = !!opts.heading;

        const font = heading ? boldFont : normalFont;
        const size = heading ? 16 : 11;
        const lineGap = heading ? 4 : 2;

        doc.font(font).fontSize(size).fillColor("#0f172a");

        const h = doc.heightOfString(text, {
          width: contentW,
          lineGap,
        });

        // If it doesn't fit, new page
        if (y + h > contentBottom) {
          doc.addPage();
          drawPageChrome();
          y = contentTop;
        }

        doc.text(text, contentX, y, {
          width: contentW,
          lineGap,
        });

        y += h + (heading ? 10 : 8);
      };

      // Title block (premium: business name as hero, Policysprint subtle already)
      if (businessName?.trim()) {
        doc.font("Helvetica-Bold").fontSize(22).fillColor("#0f172a");
        const title = `${businessName.trim()} — AI Use Policy`;
        const h = doc.heightOfString(title, { width: contentW, lineGap: 2 });
        if (y + h > contentBottom) {
          doc.addPage();
          drawPageChrome();
          y = contentTop;
        }
        doc.text(title, contentX, y, { width: contentW });
        y += h + 14;

        if (industry || country) {
          doc.font(normalFont).fontSize(10).fillColor("#334155");
          const sub = [industry?.trim(), country?.trim()].filter(Boolean).join(" · ");
          const sh = doc.heightOfString(sub, { width: contentW });
          if (y + sh > contentBottom) {
            doc.addPage();
            drawPageChrome();
            y = contentTop;
          }
          doc.text(sub, contentX, y, { width: contentW });
          y += sh + 18;
        }
      }

      // Body
      const lines = normLines(policyText);

      // Merge consecutive non-empty lines into paragraphs (prevents “one line per paragraph” bloat)
      const paras: string[] = [];
      let buf: string[] = [];

      const flush = () => {
        if (buf.length) {
          paras.push(buf.join(" ").trim());
          buf = [];
        }
      };

      for (const raw of lines) {
        const t = raw.trim();
        if (!t) {
          flush();
          continue;
        }
        // If a heading line appears, flush current paragraph and push heading alone
        if (isHeading(t)) {
          flush();
          paras.push(t);
          continue;
        }
        buf.push(t);
      }
      flush();

      for (const p of paras) {
        const heading = isHeading(p);
        writeBlock(p, { heading });
      }

      doc.end();
    } catch (e) {
      reject(e);
    }
  });
}
